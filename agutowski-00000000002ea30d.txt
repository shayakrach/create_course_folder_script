def binomd(n, k):
    res = 1.0
    cnt = 0
    for i in range(1, k+1):
        res *= n-i+1
        res /= i
        while res > 1:
          res *= 0.5
          cnt += 1
    return 0 if n-cnt > 100 else res / (2**(n-cnt))
for t in range(input()):
    w, h, l, u, r, d = map(int, raw_input().split())
    if r == w: u = 1
    if d == h: l = 1
    l, u, r, d = l-1, u-1, r-1, d-1
    
    n = w = h = max(r, d)+1
    res = 0
    p = lambda x, y: binomd(x+y, x)
    prob = plu = p(l, u)
    if u:
      pux = [0] * (n+1)
      pux[u] = p(u, u)
      pux[l] = plu
      for x in range(u+1, r+1):
        pux[x] = 0.5 * pux[x-1] * (u+x) / x
      for x in range(u-1, l, -1):
        pux[x] = 2 * pux[x+1] * (x+1) / (u+x+1)
      for x in range(l+1, r+1):
        prob += pux[x] - 0.5 * pux[x-1]
        # prob += p(u, x) - 0.5 * p(u, x-1)
    if l:
      pyl = [0] * (n+1)
      pyl[l] = p(l, l)
      pyl[u] = plu
      for y in range(l+1, d+1):
        pyl[y] = 0.5 * pyl[y-1] * (y+l) / y
      for y in range(l-1, u, -1):
        pyl[y] = 2 * pyl[y+1] * (y+1) / (y+l+1)
      for y in range(u+1, d+1):
        prob += pyl[y] - 0.5 * pyl[y-1]
        # prob += p(y, l) - 0.5 * p(y-1, l)
    print('Case #%d: %.9f' % (t+1, 1.0 - prob))
